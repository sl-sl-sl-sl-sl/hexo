{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1470380073000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1470380073000},{"_id":"source/.DS_Store","hash":"25a3921d4ca10c7c3070aa8e38aca09a1ce29e80","modified":1470379782000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1470380073000},{"_id":"source/CNAME","hash":"e529069a631eb6677fb6148781770734cbe55bcb","modified":1470290226000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1470380073000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1470380073000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1470380073000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1470380315000},{"_id":"source/_posts/unicode笔记.md","hash":"87a24c61f51da3fe599eed8d3cf878efb924c0c3","modified":1470393910000},{"_id":"source/categories/index.md","hash":"a613900e13e9aa2ead724c50adad5c8b17470216","modified":1470379715000},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1470373281000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1470380073000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1470380073000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1470380073000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1470380073000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1470380073000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1470380073000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1470380073000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1470380073000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1470380073000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1470380073000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1470380073000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1470380073000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1470380073000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1470380073000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1470380073000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1470380073000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1470380073000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1470380073000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1470380073000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1470380073000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1470380073000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1470380073000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470380073000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1470380073000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1470380073000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1470380073000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1470380073000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1470380073000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1470380073000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470380073000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1470380073000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1470380073000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1470380073000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1470380073000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1470380073000},{"_id":"public/categories/index.html","hash":"b163df30f32e7658126e8b91cf058a3bb4cd7b6e","modified":1471918073541},{"_id":"public/archives/index.html","hash":"fcecf0986232cb9c2e170ed1c545d27327cf471d","modified":1471918073541},{"_id":"public/archives/2016/index.html","hash":"5f4e8449ae4c5591fce42e4c68a932a41feb8501","modified":1471918073541},{"_id":"public/archives/2016/08/index.html","hash":"bf8617bba3b6c143f86300d088ced0aa09d5a3e8","modified":1471918073541},{"_id":"public/categories/字符串/index.html","hash":"0a625ea3321d0b1501082381df3b55bf11d15bc0","modified":1471918073542},{"_id":"public/tags/Unicode/index.html","hash":"d3309770d1d718a0b8288c56682fc0280ce17e01","modified":1471918073544},{"_id":"public/tags/NSString/index.html","hash":"b0a00b798b4130403b43f6e9198017cf19c01153","modified":1471918073544},{"_id":"public/tags/unichar/index.html","hash":"32767cd3d4e94234cf6416c73feb9ee1650401a1","modified":1471918073544},{"_id":"public/tags/UTF-32/index.html","hash":"5190c08cbd34556743644eba0ead10b08f5dc5bc","modified":1471918073545},{"_id":"public/tags/UTF-16/index.html","hash":"5f2f058ef5d2ce48a9452c7482e9b35458931d15","modified":1471918073545},{"_id":"public/tags/UTF-8/index.html","hash":"9f69aed4633dfe05e3695e3091f8df5d053111e8","modified":1471918073545},{"_id":"public/2016/08/05/unicode笔记/index.html","hash":"f28c8e628c0f7b50acacf24542d4871d4d39b67f","modified":1471918073545},{"_id":"public/index.html","hash":"0c5319a190f09337ac3fbe38ba65aacb28ff466b","modified":1471918073545},{"_id":"public/CNAME","hash":"e529069a631eb6677fb6148781770734cbe55bcb","modified":1471918073563},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1471918073563},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1471918073563},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1471918073563},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1471918073563},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1471918073563},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1471918073563},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1471918073563},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1471918073563},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1471918073564},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1471918073564},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1471918075189},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1471918075195},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1471918075195},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1471918075195},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1471918075195},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1471918075195},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1471918075195},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1471918075195},{"_id":"public/css/style.css","hash":"11c9f812d2e2c9f4980553c78844522fa960a413","modified":1471918075195},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1471918075195},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1471918075195},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1471918075196},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1471918075196}],"Category":[{"name":"字符串","_id":"cis6u0lk20003xts6sirohrux"}],"Data":[],"Page":[{"title":"categories","date":"2016-08-03T10:28:47.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-03 18:28:47\ntype: \"categories\"\n---\n","updated":"2016-08-05T06:48:35.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cis6u0ljt0001xts6xpwoxjkg","content":"","excerpt":"","more":""}],"Post":[{"title":"Unicode学习笔记","date":"2016-08-04T17:30:00.000Z","_content":"\n\n\n# Unicode\n\t\n`Unicode` 是21位编码, 不是16位, 被分为17个平面 [Plane](https://en.wikipedia.org/wiki/Plane_&#41;Unicode&#41;), 每个平面有65536个字符. 0号平面叫做基本多文种平面 (Basic Multilingual Plane, BMP), 涵盖了几乎所有字符, 除了 `emoji`.\n\n### 码点\n单一码点: 一般字符都是单一码点\n\n组合码点: 由两个码点组合而成\n\t\n`é(U+00E9) 可是看成 e(U+0065) 和 ´(U+0301) 组成`\n\n### 重复的定义\n\t\n标准等价(canonically equivalent): 不同码点或不同形式的码点, 有相同的外观与意义\n\n`A(U+0041),\tA(U+0410)`\n\n相容等价(compatibility equivalence): 相同的字符, 但在不同使用范围有不同的意义\t\n\t\n`ff(U+FB00),  f(U+0066) f(U+0066) `\n\n### 正规形式 \n\n在 `Unicode` 里, 判断字符串的等价性并不是一个简单概念, 为了鉴定标准等价与相容等价, `Unicode` 定义了正规化(normalization)算法. 正规化一个字符串的意思是：为了能使它与另一个正规化了的字符串进行二进制比较(binary-compare)\n\n` | 合成形式(é): | 分解形式 (e + ´ )\n:------------: | :-------------: | :------------:\n标准等价 | C | D\n` | precomposedStringWithCanonicalMapping | decomposedStringWithCanonicalMapping\n相容等价 | KC | KD\n` | precomposedStringWithCompatibilityMapping | decomposedStringWithCompatibilityMapping\n\n仅仅是为了比较的话, 先把字符串正规化成分解形式(D)还是合成形式(C)并不重要, 但是C包含两个步骤,先分解再合成, 所有D更快, `Unicode`联盟推荐用C的方式存储, 这是为了兼容旧的编码系统. \n\n### 字形变体\n\n`Unicode`提供一个叫做变体序列(variation sequences)的机制. 一个基准字符加上256个变体选择符\n\t`emoji`的样式就是变体序列, 例: 彩色的伞与黑白的伞  ☔️ (U+2614 U+FE0F), ☔︎ (U+2614 U+FE0E)\n\n### UTF-32\n\n`UTF-32` 每个码点上使用整32位, 每一个 `UTF-32` 都可以直接表示对应的码点, 但是从未在实际中使用, 因为每个字符占用4字节太浪费控件\n\n##UTF-16 与 代理对 (Surrogate Pairs)\n`UTF-16` 是一种长度可变的编码, 基本多文中平面(BMP)中每一个码点都直接与一个码元相映射. 其他平面(plane)都是两个16位码元来编码的, 这合起来表示一个码点的码元就叫代理对.\n\n为了避免使用 `UTF-16` 编码的字符串字节序列产生歧义, `Unicode` 限制了 `U+0800` 到 `U+DFFF` 范围内的编码用于 `UTF-16`, 这个范围外的序列为代理对的一部分. `UTF-16` 下, `U+0FFFF` 是编码最高值\n\n### 字节顺序\n\n在内存里存储的字符串, 大多数实现方式采用自己平台的CPU字节序(endianness), 而在硬盘存储和网络传输中, UTF8 语序在字符串的开头插入一个字节顺序标记(Byte Order Mask, BOM). 字节顺序标记是一个值为U+FEff的码元, 通过检查文件的头两个字节, 解码器就可以识别出其字节顺序. Unicode把高字节顺序(big-endian byte order)定为默认情况.\n\n##UTF-8 (Ken Thompson 和 Rob Pike)\n\t\n`UTF-8` 使用1~4个字节来编码一个码点. 从0到127的这些码点直接映射成1个字节(与ASCII完全相同), 接下来的1920歌码点映射成2个字节, BMP里剩下的码点需要3个字节. `Unicode` 的其他平面里的码点则需要4个字节. `UTF-8` 是基于8位的码元的, 因此不需要关心字节顺序.\n\t\n`UTF-8` 成为存储和交流 `Unicode` 文本方面的最佳编码, 由于其有效率的空间使用(仅就西方语言来讲)，以及不需要操心字节顺序, 它现在也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了.\n\n### 长度\n\t\n基本多稳重平面外的字符:\n\n随着emoji被引入`Unicode`, 经常会遇到代理对\n\n`[🌍 length] == 2  true`\n\n直接计算字符串在UTF-32编码下所需要的字节数, 再除以4\n\t\t\n`[🌍 lengthOfBytesUsingEncoding:UTF32StringEncoding]/4 == 1 true`\n\n组合字符序列:\n\t\n`如果字母 é 是以分解形式(e + ´)编码的，算作两个码元`\n\n变体序列:\n\n`他们和分解形式的组合字符序列一样`\n\n\n### NSString + Unicode\n\t\nNSString 完全建立在 `Unicode` 之上, `CFString` 也包含了 `NSString` 的底层实现.\n \n`typedef unsigned short unichar`\n\n`unichar` 为16位无符号整形, 不够用来表示21位 `Unicode` 字符.\n\n\t\t- (unichar)characterAtIndex: \t\n\t\n\t    NSString *string = @\"12🌍45\";\t// 🌍2个码元Unicode\n\t    NSLog(@\"%c\", [string characterAtIndex:1]);\n    \tNSLog(@\"%c\", [string characterAtIndex:2]);\n    \tNSLog(@\"%c\", [string characterAtIndex:3]);\n    \tNSLog(@\"%c\", [string characterAtIndex:4]);\n\n    \tLog:\n\t\t 2\n\t\t <\n\t\t 空\n\t\t 4\n\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(1, 1)]);\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(2, 1)]);\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(2, 2)]);\n    \tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(4, 1)]);\n\n    \tLog:\n    \t 2\n    \t 空\n    \t 🌍\n    \t 5\n\n   string中, 🌍的21位被截为2个16位处理, 第一个为<, 第二个未识别, 所以在使用BMP以外的Unicode时, 要特别注意\n\n\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:1]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:2]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:3]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:4]));\n    \t\n    \tLog:\n    \t\t{1, 1}\n\t\t\t{2, 2}\n\t\t\t{2, 2}\n\t\t\t{4, 1}\n\n只有在`length == 1`的时候, 才能确认`unichar`是代表单个码元, 使用 `-characterAtIndex:` 方法不会导致问题\n\n遍历String每一次都使用 `rangeOfComposedCharacterSequenceAtIndex:` 来判断字符是否是单个码元很不方便, 在 String的 `enumerateSubstringsInRange:options:usingBlock:` 方法里, 将参数指定为 `NSStringEnumerationByComposedCharacterSequences`, 内部实现了字符是单码元还是双码元的判断,\n\n加上 `NSStringEnumerationLocalized` 参数, 在定义词语间的和句子间的边界可以将用户所在的区域也考虑进去.\n\n苹果把字符串看作是子字符串的集合, 而不是字符的集合.\n\n### 比较\n\t\n字符串不会自己正规化, 所以比较字符串是否相同会得出错误的结果. `isEqual:` 和 `isEqualToString:` 都是一个字节一个字节地比较, 如果希望字符的合成和分解形式相吻合, 需要手动正规化.\n\n\t\n\t\tNSString *s = @\"\\u00E9\";\n\t\tNSString *t = @\"e\\u0301\"; // e + ´\n\t\tBOOL isEqual = [s isEqualToString:t];\n\t\tNSLog(@\"%@ is %@ to %@\", s, isEqual ? @\"equal\" : @\"not equal\", t);  \n\t\t\n\t\tLog:\n\t\t\té is not equal to é\n\n\t\tNSString *sNorm = [s precomposedStringWithCanonicalMapping];  \n\t\tNSString *tNorm = [t precomposedStringWithCanonicalMapping];  \n\t\tBOOL isEqualNorm = [sNorm isEqualToString:tNorm];  \n\t\tNSLog(@\"%@ is %@ to %@\", sNorm, isEqualNorm ? @\"equal\" : @\"not equal\", tNorm); \n\n\t\tLog:\n\t\t\té is equal to é\n\n\n另一个选择是使用 `compare:` 方法 (或 `localizedCompare:`), 这个方法返回一个和它相容等价的字符串\n\n\t\tNSString *s = @\"ff\"; // ff  \n\t\tNSString *t = @\"\\uFB00\"; // ﬀ ligature  \n\t\tNSComparisonResult result = [s localizedCompare:t];  \n\t\tNSLog(@\"%@ is %@ to %@\", s, result == NSOrderedSame ? @\"equal\" : @\"not equal\", t);  \n\n\t\tLog:\n \t\t\tff is equal to ﬀ\n\n\n 不考虑等价关系, 指示比较字符串 compare:options 指定 NSLiteralSearch 会有更快的速度\n\n\n\n### 从文件和网络读取文本\n\t\n当知道字符编码类型时, `-[NSString initWithData:encoding:]` 使用这个方法实例化字符串, 但是这个方法不提供错误信息.\n\t\n虽然文本文件本身不包含编码信息, 但 `NSString` 会通过查看扩展文件属性 (extented file attributes)或者规律试探(UTF-8文件里不会出现某些特定的二进制序列)猜测来确定文件的编码, 可以使用 `-[NSString initWithContentsOfURL:encoding:error:]` 这个方法，来从编码已知的文件里读取文本。\n\t\n如果不得不猜测文件的编码:\n\n1. 试试这两个方法：`stringWithContentsOfFile:usedEncoding:error:` 或者 `initWithContentsOfFile:usedEncoding:error:` （或者这两个方法参数为 URL 的等价方法）。 这些方法会尝试猜测资源的编码，如果猜测成功，会以引用的形式带回所用的编码。\n2. 如果 1 失败了，试着用 UTF-8 读取资源。\n3. 如果 2 失败了，试试合适的老的编码。 这里「合适的」取决于具体情况。它可以是默认的 C 语言字符串编码，也可以是 `ISO` 或者 `Windows Latin 1` 编码，亦或者是其它的，取决于你的数据来源。\n4. 最终，还可以试试 `Application Kit` 里 `NSAttributedString` 类的载入方法（比如：`initWithFileURL:options:documentAttributes:error:`）。这些方法会尝试纯文本文件，然后返回使用的编码。可以用这些方法打开任意的文档。如果你的程序并不是专业处理文本的程序，这些方法也值得考虑。对于 `Foundation` 级别的工具，或者不是自然语言的文本来说，这些方法可能不太合适。\n\n网络传输文本应该 `UTF-8` 编码, 除非有特别的需要只能用其他的编码需要向文件中写入文本, 需要使用 `writeToURL:atomically:encoding:error:`方法, 这个方法会在 `UTF-16` 或 `UTF-32` 编码文件上自动加上字节顺序标记. 它还会把文件的编码存储在名为 `com.apple.TextEncoding` 的扩展文件属性里\n\n\n本文主要参考: https://objccn.io/issue-9-1/\n\n其他链接:\n\nhttp://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt\n\t\nhttps://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html\n\t\nhttp://www.joelonsoftware.com/articles/Unicode.html\n\t\nhttps://vimeo.com/86030221\n\t\nhttp://nsconference.com\n\t\nhttps://en.wikipedia.org/wiki/Unicode\t\n\n\n\n\n\n","source":"_posts/unicode笔记.md","raw":"---\ntitle: Unicode学习笔记\ndate: 2016-08-05 01:30:00\n\ncategories:\n- 字符串\n\ntags: \n- Unicode\n- NSString\n- unichar\n- UTF-32\n- UTF-16\n- UTF-8\n\n---\n\n\n\n# Unicode\n\t\n`Unicode` 是21位编码, 不是16位, 被分为17个平面 [Plane](https://en.wikipedia.org/wiki/Plane_&#41;Unicode&#41;), 每个平面有65536个字符. 0号平面叫做基本多文种平面 (Basic Multilingual Plane, BMP), 涵盖了几乎所有字符, 除了 `emoji`.\n\n### 码点\n单一码点: 一般字符都是单一码点\n\n组合码点: 由两个码点组合而成\n\t\n`é(U+00E9) 可是看成 e(U+0065) 和 ´(U+0301) 组成`\n\n### 重复的定义\n\t\n标准等价(canonically equivalent): 不同码点或不同形式的码点, 有相同的外观与意义\n\n`A(U+0041),\tA(U+0410)`\n\n相容等价(compatibility equivalence): 相同的字符, 但在不同使用范围有不同的意义\t\n\t\n`ff(U+FB00),  f(U+0066) f(U+0066) `\n\n### 正规形式 \n\n在 `Unicode` 里, 判断字符串的等价性并不是一个简单概念, 为了鉴定标准等价与相容等价, `Unicode` 定义了正规化(normalization)算法. 正规化一个字符串的意思是：为了能使它与另一个正规化了的字符串进行二进制比较(binary-compare)\n\n` | 合成形式(é): | 分解形式 (e + ´ )\n:------------: | :-------------: | :------------:\n标准等价 | C | D\n` | precomposedStringWithCanonicalMapping | decomposedStringWithCanonicalMapping\n相容等价 | KC | KD\n` | precomposedStringWithCompatibilityMapping | decomposedStringWithCompatibilityMapping\n\n仅仅是为了比较的话, 先把字符串正规化成分解形式(D)还是合成形式(C)并不重要, 但是C包含两个步骤,先分解再合成, 所有D更快, `Unicode`联盟推荐用C的方式存储, 这是为了兼容旧的编码系统. \n\n### 字形变体\n\n`Unicode`提供一个叫做变体序列(variation sequences)的机制. 一个基准字符加上256个变体选择符\n\t`emoji`的样式就是变体序列, 例: 彩色的伞与黑白的伞  ☔️ (U+2614 U+FE0F), ☔︎ (U+2614 U+FE0E)\n\n### UTF-32\n\n`UTF-32` 每个码点上使用整32位, 每一个 `UTF-32` 都可以直接表示对应的码点, 但是从未在实际中使用, 因为每个字符占用4字节太浪费控件\n\n##UTF-16 与 代理对 (Surrogate Pairs)\n`UTF-16` 是一种长度可变的编码, 基本多文中平面(BMP)中每一个码点都直接与一个码元相映射. 其他平面(plane)都是两个16位码元来编码的, 这合起来表示一个码点的码元就叫代理对.\n\n为了避免使用 `UTF-16` 编码的字符串字节序列产生歧义, `Unicode` 限制了 `U+0800` 到 `U+DFFF` 范围内的编码用于 `UTF-16`, 这个范围外的序列为代理对的一部分. `UTF-16` 下, `U+0FFFF` 是编码最高值\n\n### 字节顺序\n\n在内存里存储的字符串, 大多数实现方式采用自己平台的CPU字节序(endianness), 而在硬盘存储和网络传输中, UTF8 语序在字符串的开头插入一个字节顺序标记(Byte Order Mask, BOM). 字节顺序标记是一个值为U+FEff的码元, 通过检查文件的头两个字节, 解码器就可以识别出其字节顺序. Unicode把高字节顺序(big-endian byte order)定为默认情况.\n\n##UTF-8 (Ken Thompson 和 Rob Pike)\n\t\n`UTF-8` 使用1~4个字节来编码一个码点. 从0到127的这些码点直接映射成1个字节(与ASCII完全相同), 接下来的1920歌码点映射成2个字节, BMP里剩下的码点需要3个字节. `Unicode` 的其他平面里的码点则需要4个字节. `UTF-8` 是基于8位的码元的, 因此不需要关心字节顺序.\n\t\n`UTF-8` 成为存储和交流 `Unicode` 文本方面的最佳编码, 由于其有效率的空间使用(仅就西方语言来讲)，以及不需要操心字节顺序, 它现在也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了.\n\n### 长度\n\t\n基本多稳重平面外的字符:\n\n随着emoji被引入`Unicode`, 经常会遇到代理对\n\n`[🌍 length] == 2  true`\n\n直接计算字符串在UTF-32编码下所需要的字节数, 再除以4\n\t\t\n`[🌍 lengthOfBytesUsingEncoding:UTF32StringEncoding]/4 == 1 true`\n\n组合字符序列:\n\t\n`如果字母 é 是以分解形式(e + ´)编码的，算作两个码元`\n\n变体序列:\n\n`他们和分解形式的组合字符序列一样`\n\n\n### NSString + Unicode\n\t\nNSString 完全建立在 `Unicode` 之上, `CFString` 也包含了 `NSString` 的底层实现.\n \n`typedef unsigned short unichar`\n\n`unichar` 为16位无符号整形, 不够用来表示21位 `Unicode` 字符.\n\n\t\t- (unichar)characterAtIndex: \t\n\t\n\t    NSString *string = @\"12🌍45\";\t// 🌍2个码元Unicode\n\t    NSLog(@\"%c\", [string characterAtIndex:1]);\n    \tNSLog(@\"%c\", [string characterAtIndex:2]);\n    \tNSLog(@\"%c\", [string characterAtIndex:3]);\n    \tNSLog(@\"%c\", [string characterAtIndex:4]);\n\n    \tLog:\n\t\t 2\n\t\t <\n\t\t 空\n\t\t 4\n\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(1, 1)]);\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(2, 1)]);\n   \t\tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(2, 2)]);\n    \tNSLog(@\"%@\", [string substringWithRange:NSMakeRange(4, 1)]);\n\n    \tLog:\n    \t 2\n    \t 空\n    \t 🌍\n    \t 5\n\n   string中, 🌍的21位被截为2个16位处理, 第一个为<, 第二个未识别, 所以在使用BMP以外的Unicode时, 要特别注意\n\n\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:1]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:2]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:3]));\n    \tNSLog(@\"%@\", NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:4]));\n    \t\n    \tLog:\n    \t\t{1, 1}\n\t\t\t{2, 2}\n\t\t\t{2, 2}\n\t\t\t{4, 1}\n\n只有在`length == 1`的时候, 才能确认`unichar`是代表单个码元, 使用 `-characterAtIndex:` 方法不会导致问题\n\n遍历String每一次都使用 `rangeOfComposedCharacterSequenceAtIndex:` 来判断字符是否是单个码元很不方便, 在 String的 `enumerateSubstringsInRange:options:usingBlock:` 方法里, 将参数指定为 `NSStringEnumerationByComposedCharacterSequences`, 内部实现了字符是单码元还是双码元的判断,\n\n加上 `NSStringEnumerationLocalized` 参数, 在定义词语间的和句子间的边界可以将用户所在的区域也考虑进去.\n\n苹果把字符串看作是子字符串的集合, 而不是字符的集合.\n\n### 比较\n\t\n字符串不会自己正规化, 所以比较字符串是否相同会得出错误的结果. `isEqual:` 和 `isEqualToString:` 都是一个字节一个字节地比较, 如果希望字符的合成和分解形式相吻合, 需要手动正规化.\n\n\t\n\t\tNSString *s = @\"\\u00E9\";\n\t\tNSString *t = @\"e\\u0301\"; // e + ´\n\t\tBOOL isEqual = [s isEqualToString:t];\n\t\tNSLog(@\"%@ is %@ to %@\", s, isEqual ? @\"equal\" : @\"not equal\", t);  \n\t\t\n\t\tLog:\n\t\t\té is not equal to é\n\n\t\tNSString *sNorm = [s precomposedStringWithCanonicalMapping];  \n\t\tNSString *tNorm = [t precomposedStringWithCanonicalMapping];  \n\t\tBOOL isEqualNorm = [sNorm isEqualToString:tNorm];  \n\t\tNSLog(@\"%@ is %@ to %@\", sNorm, isEqualNorm ? @\"equal\" : @\"not equal\", tNorm); \n\n\t\tLog:\n\t\t\té is equal to é\n\n\n另一个选择是使用 `compare:` 方法 (或 `localizedCompare:`), 这个方法返回一个和它相容等价的字符串\n\n\t\tNSString *s = @\"ff\"; // ff  \n\t\tNSString *t = @\"\\uFB00\"; // ﬀ ligature  \n\t\tNSComparisonResult result = [s localizedCompare:t];  \n\t\tNSLog(@\"%@ is %@ to %@\", s, result == NSOrderedSame ? @\"equal\" : @\"not equal\", t);  \n\n\t\tLog:\n \t\t\tff is equal to ﬀ\n\n\n 不考虑等价关系, 指示比较字符串 compare:options 指定 NSLiteralSearch 会有更快的速度\n\n\n\n### 从文件和网络读取文本\n\t\n当知道字符编码类型时, `-[NSString initWithData:encoding:]` 使用这个方法实例化字符串, 但是这个方法不提供错误信息.\n\t\n虽然文本文件本身不包含编码信息, 但 `NSString` 会通过查看扩展文件属性 (extented file attributes)或者规律试探(UTF-8文件里不会出现某些特定的二进制序列)猜测来确定文件的编码, 可以使用 `-[NSString initWithContentsOfURL:encoding:error:]` 这个方法，来从编码已知的文件里读取文本。\n\t\n如果不得不猜测文件的编码:\n\n1. 试试这两个方法：`stringWithContentsOfFile:usedEncoding:error:` 或者 `initWithContentsOfFile:usedEncoding:error:` （或者这两个方法参数为 URL 的等价方法）。 这些方法会尝试猜测资源的编码，如果猜测成功，会以引用的形式带回所用的编码。\n2. 如果 1 失败了，试着用 UTF-8 读取资源。\n3. 如果 2 失败了，试试合适的老的编码。 这里「合适的」取决于具体情况。它可以是默认的 C 语言字符串编码，也可以是 `ISO` 或者 `Windows Latin 1` 编码，亦或者是其它的，取决于你的数据来源。\n4. 最终，还可以试试 `Application Kit` 里 `NSAttributedString` 类的载入方法（比如：`initWithFileURL:options:documentAttributes:error:`）。这些方法会尝试纯文本文件，然后返回使用的编码。可以用这些方法打开任意的文档。如果你的程序并不是专业处理文本的程序，这些方法也值得考虑。对于 `Foundation` 级别的工具，或者不是自然语言的文本来说，这些方法可能不太合适。\n\n网络传输文本应该 `UTF-8` 编码, 除非有特别的需要只能用其他的编码需要向文件中写入文本, 需要使用 `writeToURL:atomically:encoding:error:`方法, 这个方法会在 `UTF-16` 或 `UTF-32` 编码文件上自动加上字节顺序标记. 它还会把文件的编码存储在名为 `com.apple.TextEncoding` 的扩展文件属性里\n\n\n本文主要参考: https://objccn.io/issue-9-1/\n\n其他链接:\n\nhttp://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt\n\t\nhttps://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html\n\t\nhttp://www.joelonsoftware.com/articles/Unicode.html\n\t\nhttps://vimeo.com/86030221\n\t\nhttp://nsconference.com\n\t\nhttps://en.wikipedia.org/wiki/Unicode\t\n\n\n\n\n\n","slug":"unicode笔记","published":1,"updated":"2016-08-05T10:45:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis6u0ljn0000xts6sta3rwns","content":"<h1 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h1><p><code>Unicode</code> 是21位编码, 不是16位, 被分为17个平面 <a href=\"https://en.wikipedia.org/wiki/Plane_&#41;Unicode&#41;\" target=\"_blank\" rel=\"external\">Plane</a>, 每个平面有65536个字符. 0号平面叫做基本多文种平面 (Basic Multilingual Plane, BMP), 涵盖了几乎所有字符, 除了 <code>emoji</code>.</p>\n<h3 id=\"码点\"><a href=\"#码点\" class=\"headerlink\" title=\"码点\"></a>码点</h3><p>单一码点: 一般字符都是单一码点</p>\n<p>组合码点: 由两个码点组合而成</p>\n<p><code>é(U+00E9) 可是看成 e(U+0065) 和 ´(U+0301) 组成</code></p>\n<h3 id=\"重复的定义\"><a href=\"#重复的定义\" class=\"headerlink\" title=\"重复的定义\"></a>重复的定义</h3><p>标准等价(canonically equivalent): 不同码点或不同形式的码点, 有相同的外观与意义</p>\n<p><code>A(U+0041),    A(U+0410)</code></p>\n<p>相容等价(compatibility equivalence): 相同的字符, 但在不同使用范围有不同的意义    </p>\n<p><code>ff(U+FB00),  f(U+0066) f(U+0066)</code></p>\n<h3 id=\"正规形式\"><a href=\"#正规形式\" class=\"headerlink\" title=\"正规形式\"></a>正规形式</h3><p>在 <code>Unicode</code> 里, 判断字符串的等价性并不是一个简单概念, 为了鉴定标准等价与相容等价, <code>Unicode</code> 定义了正规化(normalization)算法. 正规化一个字符串的意思是：为了能使它与另一个正规化了的字符串进行二进制比较(binary-compare)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">`</th>\n<th style=\"text-align:center\">合成形式(é):</th>\n<th style=\"text-align:center\">分解形式 (e + ´ )</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标准等价</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">`</td>\n<td style=\"text-align:center\">precomposedStringWithCanonicalMapping</td>\n<td style=\"text-align:center\">decomposedStringWithCanonicalMapping</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相容等价</td>\n<td style=\"text-align:center\">KC</td>\n<td style=\"text-align:center\">KD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">`</td>\n<td style=\"text-align:center\">precomposedStringWithCompatibilityMapping</td>\n<td style=\"text-align:center\">decomposedStringWithCompatibilityMapping</td>\n</tr>\n</tbody>\n</table>\n<p>仅仅是为了比较的话, 先把字符串正规化成分解形式(D)还是合成形式(C)并不重要, 但是C包含两个步骤,先分解再合成, 所有D更快, <code>Unicode</code>联盟推荐用C的方式存储, 这是为了兼容旧的编码系统. </p>\n<h3 id=\"字形变体\"><a href=\"#字形变体\" class=\"headerlink\" title=\"字形变体\"></a>字形变体</h3><p><code>Unicode</code>提供一个叫做变体序列(variation sequences)的机制. 一个基准字符加上256个变体选择符<br>    <code>emoji</code>的样式就是变体序列, 例: 彩色的伞与黑白的伞  ☔️ (U+2614 U+FE0F), ☔︎ (U+2614 U+FE0E)</p>\n<h3 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h3><p><code>UTF-32</code> 每个码点上使用整32位, 每一个 <code>UTF-32</code> 都可以直接表示对应的码点, 但是从未在实际中使用, 因为每个字符占用4字节太浪费控件</p>\n<p>##UTF-16 与 代理对 (Surrogate Pairs)<br><code>UTF-16</code> 是一种长度可变的编码, 基本多文中平面(BMP)中每一个码点都直接与一个码元相映射. 其他平面(plane)都是两个16位码元来编码的, 这合起来表示一个码点的码元就叫代理对.</p>\n<p>为了避免使用 <code>UTF-16</code> 编码的字符串字节序列产生歧义, <code>Unicode</code> 限制了 <code>U+0800</code> 到 <code>U+DFFF</code> 范围内的编码用于 <code>UTF-16</code>, 这个范围外的序列为代理对的一部分. <code>UTF-16</code> 下, <code>U+0FFFF</code> 是编码最高值</p>\n<h3 id=\"字节顺序\"><a href=\"#字节顺序\" class=\"headerlink\" title=\"字节顺序\"></a>字节顺序</h3><p>在内存里存储的字符串, 大多数实现方式采用自己平台的CPU字节序(endianness), 而在硬盘存储和网络传输中, UTF8 语序在字符串的开头插入一个字节顺序标记(Byte Order Mask, BOM). 字节顺序标记是一个值为U+FEff的码元, 通过检查文件的头两个字节, 解码器就可以识别出其字节顺序. Unicode把高字节顺序(big-endian byte order)定为默认情况.</p>\n<p>##UTF-8 (Ken Thompson 和 Rob Pike)</p>\n<p><code>UTF-8</code> 使用1~4个字节来编码一个码点. 从0到127的这些码点直接映射成1个字节(与ASCII完全相同), 接下来的1920歌码点映射成2个字节, BMP里剩下的码点需要3个字节. <code>Unicode</code> 的其他平面里的码点则需要4个字节. <code>UTF-8</code> 是基于8位的码元的, 因此不需要关心字节顺序.</p>\n<p><code>UTF-8</code> 成为存储和交流 <code>Unicode</code> 文本方面的最佳编码, 由于其有效率的空间使用(仅就西方语言来讲)，以及不需要操心字节顺序, 它现在也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了.</p>\n<h3 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h3><p>基本多稳重平面外的字符:</p>\n<p>随着emoji被引入<code>Unicode</code>, 经常会遇到代理对</p>\n<p><code>[🌍 length] == 2  true</code></p>\n<p>直接计算字符串在UTF-32编码下所需要的字节数, 再除以4</p>\n<p><code>[🌍 lengthOfBytesUsingEncoding:UTF32StringEncoding]/4 == 1 true</code></p>\n<p>组合字符序列:</p>\n<p><code>如果字母 é 是以分解形式(e + ´)编码的，算作两个码元</code></p>\n<p>变体序列:</p>\n<p><code>他们和分解形式的组合字符序列一样</code></p>\n<h3 id=\"NSString-Unicode\"><a href=\"#NSString-Unicode\" class=\"headerlink\" title=\"NSString + Unicode\"></a>NSString + Unicode</h3><p>NSString 完全建立在 <code>Unicode</code> 之上, <code>CFString</code> 也包含了 <code>NSString</code> 的底层实现.</p>\n<p><code>typedef unsigned short unichar</code></p>\n<p><code>unichar</code> 为16位无符号整形, 不够用来表示21位 <code>Unicode</code> 字符.</p>\n<pre><code>- (unichar)characterAtIndex:     \n\nNSString *string = @&quot;12🌍45&quot;;    // 🌍2个码元Unicode\nNSLog(@&quot;%c&quot;, [string characterAtIndex:1]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:2]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:3]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:4]);\n\nLog:\n 2\n &lt;\n 空\n 4\n\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(1, 1)]);\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(2, 1)]);\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(2, 2)]);\nNSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(4, 1)]);\n\nLog:\n 2\n 空\n 🌍\n 5\n</code></pre><p>   string中, 🌍的21位被截为2个16位处理, 第一个为&lt;, 第二个未识别, 所以在使用BMP以外的Unicode时, 要特别注意</p>\n<pre><code>NSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:1]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:2]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:3]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:4]));\n\nLog:\n    {1, 1}\n    {2, 2}\n    {2, 2}\n    {4, 1}\n</code></pre><p>只有在<code>length == 1</code>的时候, 才能确认<code>unichar</code>是代表单个码元, 使用 <code>-characterAtIndex:</code> 方法不会导致问题</p>\n<p>遍历String每一次都使用 <code>rangeOfComposedCharacterSequenceAtIndex:</code> 来判断字符是否是单个码元很不方便, 在 String的 <code>enumerateSubstringsInRange:options:usingBlock:</code> 方法里, 将参数指定为 <code>NSStringEnumerationByComposedCharacterSequences</code>, 内部实现了字符是单码元还是双码元的判断,</p>\n<p>加上 <code>NSStringEnumerationLocalized</code> 参数, 在定义词语间的和句子间的边界可以将用户所在的区域也考虑进去.</p>\n<p>苹果把字符串看作是子字符串的集合, 而不是字符的集合.</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>字符串不会自己正规化, 所以比较字符串是否相同会得出错误的结果. <code>isEqual:</code> 和 <code>isEqualToString:</code> 都是一个字节一个字节地比较, 如果希望字符的合成和分解形式相吻合, 需要手动正规化.</p>\n<pre><code>NSString *s = @&quot;\\u00E9&quot;;\nNSString *t = @&quot;e\\u0301&quot;; // e + ´\nBOOL isEqual = [s isEqualToString:t];\nNSLog(@&quot;%@ is %@ to %@&quot;, s, isEqual ? @&quot;equal&quot; : @&quot;not equal&quot;, t);  \n\nLog:\n    é is not equal to é\n\nNSString *sNorm = [s precomposedStringWithCanonicalMapping];  \nNSString *tNorm = [t precomposedStringWithCanonicalMapping];  \nBOOL isEqualNorm = [sNorm isEqualToString:tNorm];  \nNSLog(@&quot;%@ is %@ to %@&quot;, sNorm, isEqualNorm ? @&quot;equal&quot; : @&quot;not equal&quot;, tNorm); \n\nLog:\n    é is equal to é\n</code></pre><p>另一个选择是使用 <code>compare:</code> 方法 (或 <code>localizedCompare:</code>), 这个方法返回一个和它相容等价的字符串</p>\n<pre><code>NSString *s = @&quot;ff&quot;; // ff  \nNSString *t = @&quot;\\uFB00&quot;; // ﬀ ligature  \nNSComparisonResult result = [s localizedCompare:t];  \nNSLog(@&quot;%@ is %@ to %@&quot;, s, result == NSOrderedSame ? @&quot;equal&quot; : @&quot;not equal&quot;, t);  \n\nLog:\n     ff is equal to ﬀ\n</code></pre><p> 不考虑等价关系, 指示比较字符串 compare:options 指定 NSLiteralSearch 会有更快的速度</p>\n<h3 id=\"从文件和网络读取文本\"><a href=\"#从文件和网络读取文本\" class=\"headerlink\" title=\"从文件和网络读取文本\"></a>从文件和网络读取文本</h3><p>当知道字符编码类型时, <code>-[NSString initWithData:encoding:]</code> 使用这个方法实例化字符串, 但是这个方法不提供错误信息.</p>\n<p>虽然文本文件本身不包含编码信息, 但 <code>NSString</code> 会通过查看扩展文件属性 (extented file attributes)或者规律试探(UTF-8文件里不会出现某些特定的二进制序列)猜测来确定文件的编码, 可以使用 <code>-[NSString initWithContentsOfURL:encoding:error:]</code> 这个方法，来从编码已知的文件里读取文本。</p>\n<p>如果不得不猜测文件的编码:</p>\n<ol>\n<li>试试这两个方法：<code>stringWithContentsOfFile:usedEncoding:error:</code> 或者 <code>initWithContentsOfFile:usedEncoding:error:</code> （或者这两个方法参数为 URL 的等价方法）。 这些方法会尝试猜测资源的编码，如果猜测成功，会以引用的形式带回所用的编码。</li>\n<li>如果 1 失败了，试着用 UTF-8 读取资源。</li>\n<li>如果 2 失败了，试试合适的老的编码。 这里「合适的」取决于具体情况。它可以是默认的 C 语言字符串编码，也可以是 <code>ISO</code> 或者 <code>Windows Latin 1</code> 编码，亦或者是其它的，取决于你的数据来源。</li>\n<li>最终，还可以试试 <code>Application Kit</code> 里 <code>NSAttributedString</code> 类的载入方法（比如：<code>initWithFileURL:options:documentAttributes:error:</code>）。这些方法会尝试纯文本文件，然后返回使用的编码。可以用这些方法打开任意的文档。如果你的程序并不是专业处理文本的程序，这些方法也值得考虑。对于 <code>Foundation</code> 级别的工具，或者不是自然语言的文本来说，这些方法可能不太合适。</li>\n</ol>\n<p>网络传输文本应该 <code>UTF-8</code> 编码, 除非有特别的需要只能用其他的编码需要向文件中写入文本, 需要使用 <code>writeToURL:atomically:encoding:error:</code>方法, 这个方法会在 <code>UTF-16</code> 或 <code>UTF-32</code> 编码文件上自动加上字节顺序标记. 它还会把文件的编码存储在名为 <code>com.apple.TextEncoding</code> 的扩展文件属性里</p>\n<p>本文主要参考: <a href=\"https://objccn.io/issue-9-1/\" target=\"_blank\" rel=\"external\">https://objccn.io/issue-9-1/</a></p>\n<p>其他链接:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt\" target=\"_blank\" rel=\"external\">http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a></p>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html</a></p>\n<p><a href=\"http://www.joelonsoftware.com/articles/Unicode.html\" target=\"_blank\" rel=\"external\">http://www.joelonsoftware.com/articles/Unicode.html</a></p>\n<p><a href=\"https://vimeo.com/86030221\" target=\"_blank\" rel=\"external\">https://vimeo.com/86030221</a></p>\n<p><a href=\"http://nsconference.com\" target=\"_blank\" rel=\"external\">http://nsconference.com</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Unicode</a>    </p>\n","excerpt":"","more":"<h1 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h1><p><code>Unicode</code> 是21位编码, 不是16位, 被分为17个平面 <a href=\"https://en.wikipedia.org/wiki/Plane_&#41;Unicode&#41;\">Plane</a>, 每个平面有65536个字符. 0号平面叫做基本多文种平面 (Basic Multilingual Plane, BMP), 涵盖了几乎所有字符, 除了 <code>emoji</code>.</p>\n<h3 id=\"码点\"><a href=\"#码点\" class=\"headerlink\" title=\"码点\"></a>码点</h3><p>单一码点: 一般字符都是单一码点</p>\n<p>组合码点: 由两个码点组合而成</p>\n<p><code>é(U+00E9) 可是看成 e(U+0065) 和 ´(U+0301) 组成</code></p>\n<h3 id=\"重复的定义\"><a href=\"#重复的定义\" class=\"headerlink\" title=\"重复的定义\"></a>重复的定义</h3><p>标准等价(canonically equivalent): 不同码点或不同形式的码点, 有相同的外观与意义</p>\n<p><code>A(U+0041),    A(U+0410)</code></p>\n<p>相容等价(compatibility equivalence): 相同的字符, 但在不同使用范围有不同的意义    </p>\n<p><code>ff(U+FB00),  f(U+0066) f(U+0066)</code></p>\n<h3 id=\"正规形式\"><a href=\"#正规形式\" class=\"headerlink\" title=\"正规形式\"></a>正规形式</h3><p>在 <code>Unicode</code> 里, 判断字符串的等价性并不是一个简单概念, 为了鉴定标准等价与相容等价, <code>Unicode</code> 定义了正规化(normalization)算法. 正规化一个字符串的意思是：为了能使它与另一个正规化了的字符串进行二进制比较(binary-compare)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">`</th>\n<th style=\"text-align:center\">合成形式(é):</th>\n<th style=\"text-align:center\">分解形式 (e + ´ )</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">标准等价</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">D</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">`</td>\n<td style=\"text-align:center\">precomposedStringWithCanonicalMapping</td>\n<td style=\"text-align:center\">decomposedStringWithCanonicalMapping</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">相容等价</td>\n<td style=\"text-align:center\">KC</td>\n<td style=\"text-align:center\">KD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">`</td>\n<td style=\"text-align:center\">precomposedStringWithCompatibilityMapping</td>\n<td style=\"text-align:center\">decomposedStringWithCompatibilityMapping</td>\n</tr>\n</tbody>\n</table>\n<p>仅仅是为了比较的话, 先把字符串正规化成分解形式(D)还是合成形式(C)并不重要, 但是C包含两个步骤,先分解再合成, 所有D更快, <code>Unicode</code>联盟推荐用C的方式存储, 这是为了兼容旧的编码系统. </p>\n<h3 id=\"字形变体\"><a href=\"#字形变体\" class=\"headerlink\" title=\"字形变体\"></a>字形变体</h3><p><code>Unicode</code>提供一个叫做变体序列(variation sequences)的机制. 一个基准字符加上256个变体选择符<br>    <code>emoji</code>的样式就是变体序列, 例: 彩色的伞与黑白的伞  ☔️ (U+2614 U+FE0F), ☔︎ (U+2614 U+FE0E)</p>\n<h3 id=\"UTF-32\"><a href=\"#UTF-32\" class=\"headerlink\" title=\"UTF-32\"></a>UTF-32</h3><p><code>UTF-32</code> 每个码点上使用整32位, 每一个 <code>UTF-32</code> 都可以直接表示对应的码点, 但是从未在实际中使用, 因为每个字符占用4字节太浪费控件</p>\n<p>##UTF-16 与 代理对 (Surrogate Pairs)<br><code>UTF-16</code> 是一种长度可变的编码, 基本多文中平面(BMP)中每一个码点都直接与一个码元相映射. 其他平面(plane)都是两个16位码元来编码的, 这合起来表示一个码点的码元就叫代理对.</p>\n<p>为了避免使用 <code>UTF-16</code> 编码的字符串字节序列产生歧义, <code>Unicode</code> 限制了 <code>U+0800</code> 到 <code>U+DFFF</code> 范围内的编码用于 <code>UTF-16</code>, 这个范围外的序列为代理对的一部分. <code>UTF-16</code> 下, <code>U+0FFFF</code> 是编码最高值</p>\n<h3 id=\"字节顺序\"><a href=\"#字节顺序\" class=\"headerlink\" title=\"字节顺序\"></a>字节顺序</h3><p>在内存里存储的字符串, 大多数实现方式采用自己平台的CPU字节序(endianness), 而在硬盘存储和网络传输中, UTF8 语序在字符串的开头插入一个字节顺序标记(Byte Order Mask, BOM). 字节顺序标记是一个值为U+FEff的码元, 通过检查文件的头两个字节, 解码器就可以识别出其字节顺序. Unicode把高字节顺序(big-endian byte order)定为默认情况.</p>\n<p>##UTF-8 (Ken Thompson 和 Rob Pike)</p>\n<p><code>UTF-8</code> 使用1~4个字节来编码一个码点. 从0到127的这些码点直接映射成1个字节(与ASCII完全相同), 接下来的1920歌码点映射成2个字节, BMP里剩下的码点需要3个字节. <code>Unicode</code> 的其他平面里的码点则需要4个字节. <code>UTF-8</code> 是基于8位的码元的, 因此不需要关心字节顺序.</p>\n<p><code>UTF-8</code> 成为存储和交流 <code>Unicode</code> 文本方面的最佳编码, 由于其有效率的空间使用(仅就西方语言来讲)，以及不需要操心字节顺序, 它现在也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了.</p>\n<h3 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h3><p>基本多稳重平面外的字符:</p>\n<p>随着emoji被引入<code>Unicode</code>, 经常会遇到代理对</p>\n<p><code>[🌍 length] == 2  true</code></p>\n<p>直接计算字符串在UTF-32编码下所需要的字节数, 再除以4</p>\n<p><code>[🌍 lengthOfBytesUsingEncoding:UTF32StringEncoding]/4 == 1 true</code></p>\n<p>组合字符序列:</p>\n<p><code>如果字母 é 是以分解形式(e + ´)编码的，算作两个码元</code></p>\n<p>变体序列:</p>\n<p><code>他们和分解形式的组合字符序列一样</code></p>\n<h3 id=\"NSString-Unicode\"><a href=\"#NSString-Unicode\" class=\"headerlink\" title=\"NSString + Unicode\"></a>NSString + Unicode</h3><p>NSString 完全建立在 <code>Unicode</code> 之上, <code>CFString</code> 也包含了 <code>NSString</code> 的底层实现.</p>\n<p><code>typedef unsigned short unichar</code></p>\n<p><code>unichar</code> 为16位无符号整形, 不够用来表示21位 <code>Unicode</code> 字符.</p>\n<pre><code>- (unichar)characterAtIndex:     \n\nNSString *string = @&quot;12🌍45&quot;;    // 🌍2个码元Unicode\nNSLog(@&quot;%c&quot;, [string characterAtIndex:1]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:2]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:3]);\nNSLog(@&quot;%c&quot;, [string characterAtIndex:4]);\n\nLog:\n 2\n &lt;\n 空\n 4\n\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(1, 1)]);\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(2, 1)]);\n   NSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(2, 2)]);\nNSLog(@&quot;%@&quot;, [string substringWithRange:NSMakeRange(4, 1)]);\n\nLog:\n 2\n 空\n 🌍\n 5\n</code></pre><p>   string中, 🌍的21位被截为2个16位处理, 第一个为&lt;, 第二个未识别, 所以在使用BMP以外的Unicode时, 要特别注意</p>\n<pre><code>NSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:1]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:2]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:3]));\nNSLog(@&quot;%@&quot;, NSStringFromRange([string rangeOfComposedCharacterSequenceAtIndex:4]));\n\nLog:\n    {1, 1}\n    {2, 2}\n    {2, 2}\n    {4, 1}\n</code></pre><p>只有在<code>length == 1</code>的时候, 才能确认<code>unichar</code>是代表单个码元, 使用 <code>-characterAtIndex:</code> 方法不会导致问题</p>\n<p>遍历String每一次都使用 <code>rangeOfComposedCharacterSequenceAtIndex:</code> 来判断字符是否是单个码元很不方便, 在 String的 <code>enumerateSubstringsInRange:options:usingBlock:</code> 方法里, 将参数指定为 <code>NSStringEnumerationByComposedCharacterSequences</code>, 内部实现了字符是单码元还是双码元的判断,</p>\n<p>加上 <code>NSStringEnumerationLocalized</code> 参数, 在定义词语间的和句子间的边界可以将用户所在的区域也考虑进去.</p>\n<p>苹果把字符串看作是子字符串的集合, 而不是字符的集合.</p>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>字符串不会自己正规化, 所以比较字符串是否相同会得出错误的结果. <code>isEqual:</code> 和 <code>isEqualToString:</code> 都是一个字节一个字节地比较, 如果希望字符的合成和分解形式相吻合, 需要手动正规化.</p>\n<pre><code>NSString *s = @&quot;\\u00E9&quot;;\nNSString *t = @&quot;e\\u0301&quot;; // e + ´\nBOOL isEqual = [s isEqualToString:t];\nNSLog(@&quot;%@ is %@ to %@&quot;, s, isEqual ? @&quot;equal&quot; : @&quot;not equal&quot;, t);  \n\nLog:\n    é is not equal to é\n\nNSString *sNorm = [s precomposedStringWithCanonicalMapping];  \nNSString *tNorm = [t precomposedStringWithCanonicalMapping];  \nBOOL isEqualNorm = [sNorm isEqualToString:tNorm];  \nNSLog(@&quot;%@ is %@ to %@&quot;, sNorm, isEqualNorm ? @&quot;equal&quot; : @&quot;not equal&quot;, tNorm); \n\nLog:\n    é is equal to é\n</code></pre><p>另一个选择是使用 <code>compare:</code> 方法 (或 <code>localizedCompare:</code>), 这个方法返回一个和它相容等价的字符串</p>\n<pre><code>NSString *s = @&quot;ff&quot;; // ff  \nNSString *t = @&quot;\\uFB00&quot;; // ﬀ ligature  \nNSComparisonResult result = [s localizedCompare:t];  \nNSLog(@&quot;%@ is %@ to %@&quot;, s, result == NSOrderedSame ? @&quot;equal&quot; : @&quot;not equal&quot;, t);  \n\nLog:\n     ff is equal to ﬀ\n</code></pre><p> 不考虑等价关系, 指示比较字符串 compare:options 指定 NSLiteralSearch 会有更快的速度</p>\n<h3 id=\"从文件和网络读取文本\"><a href=\"#从文件和网络读取文本\" class=\"headerlink\" title=\"从文件和网络读取文本\"></a>从文件和网络读取文本</h3><p>当知道字符编码类型时, <code>-[NSString initWithData:encoding:]</code> 使用这个方法实例化字符串, 但是这个方法不提供错误信息.</p>\n<p>虽然文本文件本身不包含编码信息, 但 <code>NSString</code> 会通过查看扩展文件属性 (extented file attributes)或者规律试探(UTF-8文件里不会出现某些特定的二进制序列)猜测来确定文件的编码, 可以使用 <code>-[NSString initWithContentsOfURL:encoding:error:]</code> 这个方法，来从编码已知的文件里读取文本。</p>\n<p>如果不得不猜测文件的编码:</p>\n<ol>\n<li>试试这两个方法：<code>stringWithContentsOfFile:usedEncoding:error:</code> 或者 <code>initWithContentsOfFile:usedEncoding:error:</code> （或者这两个方法参数为 URL 的等价方法）。 这些方法会尝试猜测资源的编码，如果猜测成功，会以引用的形式带回所用的编码。</li>\n<li>如果 1 失败了，试着用 UTF-8 读取资源。</li>\n<li>如果 2 失败了，试试合适的老的编码。 这里「合适的」取决于具体情况。它可以是默认的 C 语言字符串编码，也可以是 <code>ISO</code> 或者 <code>Windows Latin 1</code> 编码，亦或者是其它的，取决于你的数据来源。</li>\n<li>最终，还可以试试 <code>Application Kit</code> 里 <code>NSAttributedString</code> 类的载入方法（比如：<code>initWithFileURL:options:documentAttributes:error:</code>）。这些方法会尝试纯文本文件，然后返回使用的编码。可以用这些方法打开任意的文档。如果你的程序并不是专业处理文本的程序，这些方法也值得考虑。对于 <code>Foundation</code> 级别的工具，或者不是自然语言的文本来说，这些方法可能不太合适。</li>\n</ol>\n<p>网络传输文本应该 <code>UTF-8</code> 编码, 除非有特别的需要只能用其他的编码需要向文件中写入文本, 需要使用 <code>writeToURL:atomically:encoding:error:</code>方法, 这个方法会在 <code>UTF-16</code> 或 <code>UTF-32</code> 编码文件上自动加上字节顺序标记. 它还会把文件的编码存储在名为 <code>com.apple.TextEncoding</code> 的扩展文件属性里</p>\n<p>本文主要参考: <a href=\"https://objccn.io/issue-9-1/\">https://objccn.io/issue-9-1/</a></p>\n<p>其他链接:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt\">http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt</a></p>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html\">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html</a></p>\n<p><a href=\"http://www.joelonsoftware.com/articles/Unicode.html\">http://www.joelonsoftware.com/articles/Unicode.html</a></p>\n<p><a href=\"https://vimeo.com/86030221\">https://vimeo.com/86030221</a></p>\n<p><a href=\"http://nsconference.com\">http://nsconference.com</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Unicode\">https://en.wikipedia.org/wiki/Unicode</a>    </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cis6u0ljn0000xts6sta3rwns","category_id":"cis6u0lk20003xts6sirohrux","_id":"cis6u0lk40005xts6tt8zxx3w"}],"PostTag":[{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0ljx0002xts6xt1tpuvz","_id":"cis6u0lk6000axts6v2ey6m40"},{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0lk30004xts6vbrhg659","_id":"cis6u0lk6000bxts6mt8dshij"},{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0lk40006xts636r0hcr7","_id":"cis6u0lk6000cxts64z0pkfen"},{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0lk50007xts6hkfica8p","_id":"cis6u0lk6000dxts6rwzljs7f"},{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0lk50008xts6jw7aoz2r","_id":"cis6u0lk6000exts68mqi1qoy"},{"post_id":"cis6u0ljn0000xts6sta3rwns","tag_id":"cis6u0lk50009xts60vjt012k","_id":"cis6u0lk6000fxts66lxexltv"}],"Tag":[{"name":"Unicode","_id":"cis6u0ljx0002xts6xt1tpuvz"},{"name":"NSString","_id":"cis6u0lk30004xts6vbrhg659"},{"name":"unichar","_id":"cis6u0lk40006xts636r0hcr7"},{"name":"UTF-32","_id":"cis6u0lk50007xts6hkfica8p"},{"name":"UTF-16","_id":"cis6u0lk50008xts6jw7aoz2r"},{"name":"UTF-8","_id":"cis6u0lk50009xts60vjt012k"}]}}